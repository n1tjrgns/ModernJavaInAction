## 모던자바인액션 2&3장

----

#### 2.1 변화하는 요구사항에 대응하기

**동작 파라미터화**를 사용해서 변화에 대응할 수 있는 유연한 코드를 만드는 방법을 알아보자.

- 메소드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메소드 인수로 전달한다.
- 코드 전달 기법으로 익명 클래스를 사용해 전달할 수 있지만, 자바8에서는 인터페이스를 상속받아 여러 클래스를 구현해야 하는 수고를 없앨 수 있는 방법을 제공한다. (람다)
- 정렬(Comparator), 쓰레드(Runnable), GUI 처리를 포함한 다양한 동작으로 파라미터화가 가능하다.

-----

### 3. 람다 표현식

#### 3.1 람다란 무엇인가?

메소드로 전달할 수 있는 익명 함수를 단순화한 것

- 익명 : 보통 메소드와 달리 이름이 없다.
- 함수 : 람다는 메소드처럼 특정 클래스에 종속되지 않기에 함수라고한다.
- 전달 : 람다 표현식을 메소드 인수로 전달하거나 변수로 저장할 수 있다.
- 간결성 : 익명 클래스처럼 복잡하게 구현하지 않아도 된다.

```java
Comparator<Apple> byWeight = new Comparator<Apple>(){
	public int compare(Apple a1, Apple a2){
		return a1.getWeight().compareTo(a2.getWeight());
	}
}
```

```java
Comparator<Apple> byWeight = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```



람다 파라미터,                   화살표             람다 바디로 이루어진다.

`(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());`



(parameters) - > 표현식

(parameters) - > {구문;} 식의 방식으로 작성해야한다.



#### 3.2 어디에, 어떻게 람다를 사용할까?

함수형 인터페이스 문맥에서 사용가능 (응..?)

앞에서 만든 Predicate 인터페이스와 같이 오직 하나의 추상메소드를 말한다.

인터페이스에 **디폴트 메소드**가 있더라도 **추상 메소드가 오직 하나면 함수형 인터페이스**이다.



#### @FunctionalInterface

- 함수형 인터페이스임을 나타내는 어노테이션
- 실제로 함수형 인터페이스가 아니라면 에러발생



#### 3.3 람다 활용 : 실행 어라운드 패턴

초기화/준비 -> 작업 -> 정리/마무리의 형식 코드를 실행 어라운드 패턴이라고 부른다.

ex) BufferedReader 같은



#### 3.4 함수형 인터페이스 사용

#### 3.4.1 Predicate

- negate(정반대), and, or 메소드 제공

#### 3.4.2 Consumer

#### 3.4.3 Function

- andThen, compose 두 가지 디폴트 메소드 제공

f.andThen(g) -> f의 결과를 g에 전달하여 계속 작업

f.compose(g) -> g의 작업부터 진행 후 f에 전달하여 계속 작업



#### 기본형 특화

자바에서의 제네릭 파라미터에는 참조형밖에 쓸 수 없다.

> 왜?

제네릭의 내부 구현 때문에.

그래서 자바에서 기본형을 참조형으로 변환하는 **박싱**이 필요한 것이다.

프로그래머가 편리하게 코드를 구현할 수 있도록 **오토박싱**도 제공이된다.

하지만, 이러한 변환 과정은 비용이 추가적으로 발생한다.

박싱한 값은 힙 영역에 저장되기 때문에, 기본형을 가져올 때도 메모리를 탐색해야하는 과정이 필요하다. 



#### 함수형 인터페이스에서의 예외처리

함수형 인터페이스는 확인된 예외를 던지는 동작을 허용하지 않는다.

예외를 던지는 람다 표현식을 만들려면 확인된 예외를 선언하는 함수형 인터페이스를 직접 정의하거나, 람다를 try/catch로 감싸줘야한다.

```java
@FunctionalInterface
public interface BufferedReaderProcessor {
	String process(BufferdReader b) throws IOException;
}
```



함수형 인터페이스로 직접 정의하기 어려운 경우에는?

```java
Function<BufferedReader, String> f = (BufferedReader b) -> {
  try {
    return b.readLine():
  }catch(IOException e){
    throw new RuntimeException(e);
  }
}
```



#### 다이아몬드 연산자

제네릭에서 다이아몬드 연산자가 콘텍스트에 따른 제네릭 형식을 추론할 수 있다.



#### 3.5.1 형식 검사

다이아몬드 연산자처럼 람다가 사용되는 콘텍스트를 이용해 람다의 형식을 추론할 수 있다.

자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 이용해 람다 표현식과 관련된 함수형 인터페이스를 추론한다.

상황에 따라 명시적으로 형식을 포함하는 것이 좋을 때도 있고, 배제하는것이 가독성을 향상시킬 때도 있다.



#### 3.5.4 지역 변수 사용

람다식은 마찬가지로 외부에서 정의된 변수도 활용할 수 있다.

하지만, 그러기 위해서는 **지역변수는 final로 선언되어있거나, final로 선언된것처럼 사용**해야한다.



> 왜?

인스턴스 변수는 힙에 저장되는 반면, 지역변수는 스택에 위치한다.

람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행되면 변수를 할당한 스레드가 사라져 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서 해당 변수에 접근하려 할 수 있다.

* 지역변수는 스택 영역에 존재하기 때문에 자신을 정의한 스레드와 생존을 같이해야한다.

따라서 자바 구현에서는 원래 변수에 접근을 허용하는 것이 아닌 지역 변수의 복사본을 제공한다. 

그렇기 때문에 복사본의 값이 바뀌지 않아야 하므로 한 번만 값을 할당해야 한다.

이러한 지역 변수의 제약 때문에 외부 변수를 변화시키는 일반 명령형 프로그래밍 패턴에 제동을 걸 수 있다.



#### 3.6 메소드 참조

메소드 참조를 통해 **가독성**을 높일 수 있다.



#### 메소드 참조 만드는 세가지 방법

1. 정적 메소드 참조

   Integer의 ParseInt -> Integer::parseInt

2. 다양한 형식의 인스턴스 메소드 참조

   String의 length -> String::length

3. 기존 객체의 인스턴스 메소드 참조

   Transaction 객체를 할당받은 지역변수와, Transaction 객체의 getvalue 메소드가 있을때

   지역변수이름::getValue



#### 편리해진 정렬

```
inventory.sort(comparing(Apple::getWeight)
	.reversed()
	.thenComparing(Apple::getCountry));;
```



#### 요약

- 람다 표현식은 익명 함수의 일종. 이름은 없지만, 파라미터 리스트, 바디 ,반환형식을 가지며 예외를 던질 수 있다.
- 함수형 인터페이스는 하나의 추상메소드만을 정의하는 인터페이스다.
- 람다 표현식 전체가 함수형 인터페이스의 인스턴스로 취급된다.
- 실행 어라운드 패턴(자원 할당, 정리) 과 같은 람다와 활용하면 유연성과 재사용성을 추가로 얻을 수 있다.
- Comparator, Predicate, Function 같은 함수형 인터페이스는 람다 표현식을 조합할 수 있는 다양한 디폴트 메소드를 제공한다.


