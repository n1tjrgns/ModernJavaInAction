## 자바의 미래

----

자바는 시대의 흐름에 맞게 변화해왔다고 생각한다.

하드웨어의 발전으로 멀티코어를 충분히 활용할 수 있어야했고, 넘쳐나는 데이터들 속에서 조금 더 간결하게 데이터를 처리할 수 있어야했다.

필드를 추가,삭제 하거나 반복문을 적용하는 등 기존의 객체지향, 명령형 언어로는 시대의 흐름을 따라가기엔 어려웠다.

하지만 많은 변화가 있었던 만큼 낯설게 느껴질 수 있다. ~~(내 얘기..?)~~

그동안 쭉 나왔던 내용을 간단하게 짚고 넘어가자.



1. #### 동작 파라미터화(람다와 메소드 참조)

자바8 부터 메소드가 일급객체로 지원이 가능하기 때문에 파라미터로 전달이 가능하다.



2. #### 스트림

자바의 컬렉션, 반복자, for-each 구문은 오랫동안 많이 사용된 기능이다.

> 컬렉션에 filter, map 등의 메소드를 추가해서 버전업을 했어도 됐을텐데.. 왜 스트림이라는 새로운 API를 만들었을까?

**컬렉션의 경우** 계산 과정을 일일이 다시 담아 놓고 기억을 해야하며, 계산 후의 결과 값을 가지고 추가로 작업을 진행해야한다.

작업이 많아질 수록 연산을 위한 for문이 증가할 것이다.

하지만 **스트림 API**는 연산을 파이프라인이라는 게으른 연산으로 구성한다. 한 번의 탐색으로 모든 연산을 수행하기 때문에 큰 데이터 집합일 수록 스트림의 데이터 처리 방식이 효율적이다.

또한 메모리 캐시 등의 관점에서도 탐색 횟수를 최소화해 성능을 꽤할 수 있다.

스트림의 parallel 메소드로 스트림을 병렬로 처리할 때도 한몫한다. **상태 변화**는 병렬성의 큰 걸림돌이다.

따라서 불변, 동작 파라미터화, 내부 반복은 함수형 개념의 핵심이 된다.



3. #### CompletableFuture

자바5부터 Future 인터페이스를 제공해준다. 이를 이용해 여러 작업이 동시에 실행될 수 있도록 다른 스레드나 코어 작업을 할당할 수 있다. 결과가 필요할 때는 get 메소드를 호출해 생성된 Future가 완료될 때까지 기다릴 수 있다.

- 스트림에서는 파이프라인 연산을 구성할 수 있으므로 map, filter 등으로 동작 파라미터화를 제공한다. 이로써 반복자를 사용했을 때 생기는 불필요한 코드를 피할 수 있다.
- 마찬가지로 CompletableFuture는 Future와 관련된 공통 디자인 패턴을 함수형 프로그래밍으로 간결하게 표현할 수 있도록 thenCompose, thenCombine, allOf 등을 제공한다.



4. #### Optional

자바8은 T형식의 값을 반환하거나, 값이 없음을 의미하는 Optional.empty 를 반환하는 Optional<T> 클래스를 제공한다.

null 처리에 특화되어있는 클래스다. 이로써 NPE를 방지할 수 있다. 값이 없는 상황을 라이브러리에서 확인할 수 있다.



5. Flow API

자바9 에서는 역압력 프로토콜을 표준화했다. 호솬성을 높일 수 있도록 4개의 인터페이스(Publisher, Subscriber, Subscription, Processor)를 포함한다.



6. 디폴트 메소드

기존 기능에 아무런 영향을 미치지 않으면서 인터페이스에 default method를 추가할 수 있다. 

특히 인터페이스의 특성상 기존의 모든 상속 받는 클래스에 해당 기능을 구현을 해야한다는 부분을 상쇄시켜주는 아주 훌륭한 메소드이다.



7. 자바9 모듈 시스템

- 안정적 설정 : 모듈 요구사항을 명시적으로 선언함으로 의존성 빠짐, 충돌, 순환 문제를 런타임이 아닌 빌드 과정에서 확인간으
- 강한 캡슐화 : 자바 모듈 시스템은 특정 패키지만 노출한 다음 각 모듈에서 공개할 부분과 내부 구현의 영역 접근을 분리할 수 있다.
- 보안서 개선 : 사용자가 모듈의 특정 부분을 사용할 수 없도록 함으로써 해커가 보안 제어를 뚫기가 어려워졌다.
- 성능 개선 : 클래스가 런타임이 로드된 다른 클래스를 참조하는 상황보다는 적은 수의 컴포너트를 참조할 때최적화 기술이 더 효과를 발휘한다.
- 확장성 : 자바 모듈 시스템은 자바 SE 플랫폼을 작은 부분으로 나눔으로 실행중인 어플리케이션에서 필요한 부분만 사용할 수 있다.



8. 자바10 지역 변수형 추론

컨텍스트로 형식을 유추할 수 있는 상황에서는 제네렉의 형식 파라미터를 생략할 수 있다.

```java
//자바7 이전
Map<String, List<String>> myMap = new HashMap<String, List<String>>();

//자바7 이후
Map<String, List<String>> myMap = new HashMap<>();

Function<Integer, Boolean> p = (Integer x) -> booleanExpression;

-> Function<Integer, Boolean> p = x -> booleanExpression;
```

형식이 생략되면 컴파일러가 생략된 형식을 추론한다.



아래는 자바10부터 추가된 지역 변수형 추론이다.

```java
var myMap = new HashMap<String, List<String>>();
```



하지만 지역 변수형 추론 과정에서는 몇 가지 문제가 발생할 수 있다.

```java
var x = new Car();
```

Vehicle을 상속하는 Car 가 존재할 때 x는 Vehicle 일까 car 일까?

변수의 형식은 초기화 형식과 같다고 간주한다. 따라서 car가된다. 또한 초기화 코드가 없다면 var를 사용할 수 없다는 제약조건이 있다.

하지만 만약 시스템이 사용자와 의도했던 형식과 다른 형식을 추론하는 경우 문제가 발생한다. 따라서 두 가지 이상의 형식으로 추론할 수 있는 상황에서는 에러를 발생시키는 것이 바람직하다.



9. #### 구체화된 제네릭

제네릭은 기존 JVM과 호환성을 유지해야 했기 때문에, 런타임 시점에는 ArrayList<String> 이나 ArrayList<Integer> 표현이 같았다. 이를 **제네릭 다형성의 삭제 모델**이라고 한다. 이 때문에 호환성 유지를 위한 런타임 비용을 약간 지불하게되었으며, 제네릭의 형식 파라미터로 객체만 사용할 수 있게 되었다(Wrapper 클래스)

여기서 우리는 ArrayList의 컨텐츠를 구분할 수 있는 방법을 걱정해야한다.

> 왜?

GC 때문이다. 만약에 객체 일경우 (GC가 사용중인지 아닌지 체크) 아닌 경우 (기본값의 경우 GC 수행자체가 불가능하기 때문에) 분간을 해야하기 때문이다.그렇기에 선언이 같다면 GC가 필드가 참조형인지 기본형인지 알 수 있도록 충분한 형식 정보를 런타임에 유지해야한다. 이를 **제네릭 다형성 구체화모델** 또는 구체화된 제네릭이라고 부른다.



10. #### 더 근본적인 불변 지원

자바에서 함수형 프로그래밍을 구현하려면 **불변값**을 언어적으로 지원해야 한다.

final은 필드값 갱신만 막을 수 있기 때문에, 완전한 불변이라고는 말할 수 없다.

```java
final int[] arr = {1,2,3}; // arr = ~ 은 불가능하지만 arr[1] = 2 는 가능
final List<T> list = new ArrayList<>(); //마찬가지
```

기본형에서는 값이 바뀌는 것을 막을 수 있지만, 객체 참조에서는 큰 효과가 없다.

값 형식이라는 개념을 살펴봐야한다.



11. #### 값 형식

값 형식에 기반한 변수는 직접 값을 포함한다. 한 값 형식 변수의 값을 다른 값 형식 변수에 할당하면 포함된 값이 복사된다.

참조 형식 변수의 할당에서는 객체 자체가 아니라 객체의 참조가 복사된다는 점이 다르다.



함수형 프로그래밍에서는 식별자가 없는 불변값을 이용하므로 자바에서 값 형식을 지원한다면 좋을 것이다.

아마 값 형식이 지원된다면 제네릭이 사라질 것이다.